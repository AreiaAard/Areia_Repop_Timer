<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
    name="Areia_Repop_Timer"
    author="Areia"
    id="eb83ae87839b08cf69f80ad2"
    language="Lua"
    purpose="Track area repops"
    save_state="y"
    date_written="2021-12-30 15:00:00"
    requires="5.06"
    version="0.02"
    >
<description trim="y">
<![CDATA[
]]>
</description>

</plugin>

<include name="constants.lua"/>



<aliases>
    <alias
        match="^ *art +config +chan(?:nel)? *$"
        enabled="y"
        script="Config.channel"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +chan(?:nel)? +(?<val>\w.*\w) *$"
        enabled="y"
        script="Config.channel"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>

    <alias
        match="^ *art +config +alias(?:es)? *$"
        enabled="y"
        script="Config.zone_aliases"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +alias(?:es)? +(?<alias>\w+) *$"
        enabled="y"
        script="Config.zone_aliases"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +alias(?:es)? +(?<alias>\w+) +(?<zone>\w+) *$"
        enabled="y"
        script="Config.zone_aliases"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>

    <alias
        match="^ *art +config +notif(?:y|ications?) *$"
        enabled="y"
        script="Config.notify"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +notif(?:y|ications?) +(?<val>on|off) *$"
        enabled="y"
        script="Config.notify"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
require "commas"
require "copytable"
require "gmcphelper"
require "serialize"
require "tprint"
require "var"
require "wait"
dofile(GetInfo(60) .. "aardwolf_colors.lua")



--------------------------------------------------
-- Config
--------------------------------------------------

Config = {}

function Config.initialize()
    Config.load()
end

function Config.default()
    local data = {
        ["channel"] = "",
        ["zoneAliases"] = {},
        ["notify"] = true,
    }
    return serialize.save_simple(data)
end

function Config.load()
    local strvar = var.config or Config.default()
    local data = loadstring("return " .. strvar)()
    Config.data = data
end

function Config.save()
    var.config = serialize.save_simple(Config.data)
end

function Config.get(key)
    return Config.data[key]
end

function Config.set(key, val)
    Config.data[key] = val
    Config.save()
end

function Config.channel(alias, line, wc)
    local val = wc.val and wc.val:lower() or nil
    if (val) then
        val = val == "default" and "" or val
    Config.set("channel", val)
    end

    val = Config.get("channel")
    val = val == "" and "plugin message" or val
    Utility.msg_prim(string.format("Default channel is @Y%s", val))
end

function Config.display_zone_aliases(alias)
    local zoneAliases = Config.get("zoneAliases")
    local display = {}

    if (alias) then
        table.insert(display, alias)
    else
        for alias, _ in pairs(zoneAliases) do
            table.insert(display, alias)
        end
    end

    if (#display == 0) then
        Utility.msg_prim("No zone aliases are defined.")
        return
    end

    table.sort(display)
    Utility.msg_prim("@YAlias    @w: @YZone:")
    Utility.msg_sec("---------:-----------")
    for _, alias in ipairs(display) do
        local zone = zoneAliases[alias]
        local line = string.format(
            "%-8.8s : %-10.10s", alias,
            zone and Utility.pascal_case(zone) or "(None)"
        )
        Utility.msg_sec(line)
    end
end

function Config.set_zone_alias(zone, alias)
    if not (zone and alias) then
        return
    end

    zone = zone:lower()
    alias = alias:lower()
    Config.get("zoneAliases")[alias] = zone
    Config.save()
    Config.display_zone_aliases(alias)
end

function Config.check_zone_alias(zone)
    zone = zone:lower()
    return Config.get("zoneAliases")[zone] or zone
end

function Config.zone_aliases(alias, line, wc)
    local zone = wc.zone
    local alias = wc.alias
    if (zone) then
        return Config.set_zone_alias(zone, alias)
    end
    Config.display_zone_aliases(alias)
end

function Config.notify(alias, line, wc)
    local val = wc.val and wc.val:lower() or nil
    if (not val) then
        -- Flip the flag if no arg was given.
        val = Config.get("notify") and "off" or "on"
    end

    if (val == "on") then
        Config.set("notify", true)
    elseif (val == "off") then
        Config.set("notify", false)
    else
        Utility.plugin_msg("Syntax: @Yart config notify [on|off]")
        return
    end

    val = Config.get("notify") and "on" or "off"
    Utility.msg_prim(string.format("Pre-repop notifications turned %s.", val))
end
]]>
</script>



<aliases>
    <alias
        match="^ *art +track *$"
        enabled="y"
        script="Timer.track"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +check *$"
        enabled="y"
        script="Timer.check"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +check *(?<zone>\w+) *$"
        enabled="y"
        script="Timer.check"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +check *(?<zone>\w+) *(?<channel>\w.*\w) *$"
        enabled="y"
        script="Timer.check"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>

    <alias
        match="^ *art +reset *$"
        enabled="y"
        script="Timer.reset"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +reset +(?<zone>\w+) *$"
        enabled="y"
        script="Timer.reset"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
</aliases>

<triggers>
    <trigger
        group="trigger_group_sense"
        match="^You are in area : (?<areaName>.+)$"
        enabled="n"
        script="Timer.get_area"
        regexp="y"
        sequence="100"
    >
    </trigger>

    <trigger
        group="trigger_group_sense"
        match="^You sense that life will return to this area in roughly (\d+)-(\d+) minutes\.$"
        enabled="n"
        script="Timer.get_minutes"
        regexp="y"
        sequence="100"
    >
    </trigger>
    <trigger
        group="trigger_group_sense"
        match="^You sense that life will return to this area within (.+)\.$"
        enabled="n"
        script="Timer.get_seconds"
        regexp="y"
        sequence="100"
    >
    </trigger>
</triggers>

<script>
<![CDATA[
--------------------------------------------------
-- Timer
--------------------------------------------------

Timer = {}

function Timer.initialize()
    -- Capture full area name from 'where' here
    Timer.areaName = ""

    --[[ Structure of each element in Timer.senseTimes:
    zone = {
        areaName = string, -- Full area name
        nextRepop = number, -- Time of next repop
        certain = bool, -- Weather nextRepop is calculated from previous repop
    }
    ]]
    Timer.senseTimes = {} 
end

function Timer.clear_sense(zone)
    if (zone) then
        Timer.senseTimes[zone] = nil
        return
    end
    Timer.senseTimes = {}
end

function Timer.refresh_sense(time)
    for zone, senseData in pairs(Timer.senseTimes) do
        if (time >= senseData.nextRepop) then
            Timer.clear_sense(zone)
        end
    end
end

function Timer.refresh_data()
    local now = os.time()
    Timer.refresh_sense(now)
    GMCP.refresh_repop(now)
end

function Timer.add_timer(name, minute, second, script)
    if (not Config.get("notify") or minute > 59 or second >= 60) then
        -- Invalid min/sec values, but possible to receive these for
        -- very long repop times. Probably don't want to create a
        -- timer in that case regardless.
        return
    end

    local fullName = string.format("timer_%s", name)
    local flags = timer_flag.Enabled + timer_flag.OneShot
        + timer_flag.Replace + timer_flag.Temporary
    local retVal = AddTimer(fullName, 0, minute, second, script, flags)

    if (retVal ~= eOK) then
        local errorMsg = string.format("Failed to add timer (%d):", retVal)
        Utility.msg_prim(errorMsg, error_desc[retVal])
        return
    end

    SetTimerOption(fullName, "send_to", sendto.script)
end

function Timer.convert_time(time)
    local day, hour, minute, second = 0, 0, 0, 0

    local dayLength = 60 * 60 * 24
    if (time >= dayLength) then
        day = math.floor(time / dayLength)
        time = time % dayLength
    end

    local hourLength = 60 * 60
    if (time >= hourLength) then
        hour = math.floor(time / hourLength)
        time = time % hourLength
    end

    local minuteLength = 60
    if (time >= minuteLength) then
        minute = math.floor(time / minuteLength)
        time = time % minuteLength
    end

    second = time
    return {day=day, hour=hour, minute=minute, second=second}
end

function Timer.format_time(time)
    local conversion = Timer.convert_time(time)
    local msg = {}

    for _, span in ipairs{"day", "hour", "minute", "second"} do
        local spanCount = conversion[span]
        if (spanCount > 0) then
            --local plural = spanCount > 1 and "s" or ""
            --local str = string.format("%d %s%s", spanCount, span, plural)
            local str = string.format("%d%s", spanCount, span:sub(1, 1))
            table.insert(msg, str)
        end
    end

    return table.concat(msg, ", ")
end

function Timer.get_area(trigger, line, wc)
    Timer.areaName = trim(wc.areaName)
end

function Timer.get_minutes(trigger, line, wc)
    local now = os.time()
    local zone = GMCP.get_zone()
    local previousRepop = GMCP.repopTimes[zone]
    local senseData = {}
    local nextRepop = 0
    local certain = false
    local timerMinutes, timerSeconds = 0, 0

    if (previousRepop) then
        certain = true
        local seconds = (previousRepop - now) % 60
        nextRepop = now + (60 * tonumber(wc[1])) + seconds
        local timerAllSeconds = nextRepop - now - 30
        timerMinutes = math.floor(timerAllSeconds / 60)
        timerSeconds = timerAllSeconds % 60
    else
        nextRepop = now + (60 * tonumber(wc[2]))
        timerMinutes = tonumber(wc[1])
    end

    Timer.add_timer(
        string.format("repop_%s", zone),
        timerMinutes, timerSeconds,
        string.format("Execute('art check %s')", zone)
    )

    senseData.areaName = Timer.areaName
    senseData.nextRepop = nextRepop
    senseData.certain = certain
    Timer.senseTimes[zone] = senseData

    Timer.check()
    EnableTriggerGroup("trigger_group_sense", false)
end

function Timer.get_seconds(trigger, line, wc)
    local now = os.time()
    local zone = GMCP.get_zone()
    local previousRepop = GMCP.repopTimes[zone]
    local senseData = {}
    local nextRepop = now
    local certain = false
    local repopInNextSeconds = 0

    if (previousRepop) then
        certain = true
        repopInNextSeconds = (previousRepop - now) % 60
    else
        repopInNextSeconds = wc[1] == "the next 30 seconds" and 30 or 60
    end

    nextRepop = nextRepop + repopInNextSeconds
    senseData.areaName = Timer.areaName
    senseData.nextRepop = nextRepop
    senseData.certain = certain
    Timer.senseTimes[zone] = senseData

    Timer.check()
    EnableTriggerGroup("trigger_group_sense", false)
end

function Timer.track(alias, line, wc)
    Timer.refresh_data()
    local zone = GMCP.get_zone()

    if (Timer.senseTimes[zone]) then
        Timer.check()
        return
    end

    EnableTriggerGroup("trigger_group_sense", true)
    SendNoEcho("where")
    SendNoEcho("cast 'sense life'")
end

function Timer.get_repop(zone)
    local now = os.time()
    local senseData = Timer.senseTimes[zone]
    zone = Utility.pascal_case(zone)
    Timer.refresh_data()

    if (not senseData) then
        return string.format("@WNo repop data for %s.$C", zone)
    end

    local formattedRepop = Timer.format_time(senseData.nextRepop - now)
    if (formattedRepop == "") then
        -- Possible if time is <= 0, which means the area has already
        -- repopped, or is extremely close to repop.
        return string.format("@W%s has repopped.$C", zone)
    end

    local certain = senseData.certain and "in" or "in approximately"
    return string.format(
        "@WRepop of %s %s @Y%s@W.$C",
        senseData.areaName, certain, formattedRepop
    )
end

function Timer.check(alias, line, wc)
    wc = wc or {}
    local channel = wc.channel and wc.channel:lower() or Config.get("channel")
    local zone = wc.zone and wc.zone:lower() or GMCP.get_zone()
    zone = Config.check_zone_alias(zone)
    local msg = Timer.get_repop(zone)

    if (channel == "") then
        Utility.msg_prim(msg)
        return
    end
    Execute(string.format("%s %s", channel, msg))
end

function Timer.reset(alias, line, wc)
    local zone = wc.zone and Config.check_zone_alias(wc.zone) or nil
    Timer.clear_sense(zone)
    GMCP.clear_repop(zone)

    local msg = "Reset repop data for %s."
    msg = msg:format(zone and Utility.pascal_case(zone) or "all areas")
    Utility.msg_prim(msg)
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- GMCP
--------------------------------------------------

GMCP = {}

function GMCP.initialize()
    GMCP.repopTimes = {}
end

function GMCP.get_zone()
    return gmcp("room.info.zone")
end

function GMCP.clear_repop(zone)
    if (zone) then
        GMCP.repopTimes[zone] = nil
        return
    end
    GMCP.repopTimes = {}
end

function GMCP.refresh_repop(time)
    for zone, repopTime in pairs(GMCP.repopTimes) do
        if (time - repopTime > 1800) then
            GMCP.clear_repop(zone)
        end
    end
end

function GMCP.repop()
    local zone = GMCP.get_zone()
    local now = os.time()
    GMCP.repopTimes[zone] = now
    Timer.senseTimes[zone] = nil
end
]]>
</script>



<aliases>
    <alias
     match="^ *art +update *$"
     enabled="y"
     script="Remote.update_plugin"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
--------------------------------------------------
-- Remote
--------------------------------------------------

local https = require "ssl.https"

Remote = {}

function Remote.update_plugin(alias, line, wc)
    local url = "https://raw.githubusercontent.com/AreiaAard/Areia_Repop_Timer/main/areia_repop_timer.xml"
    local xml = https.request(url)
    if (not xml) then
        Utility.msg_prim("Failed to download remote plugin file.")
        return false
    end

    local pluginID = GetPluginID()
    local localVersion = GetPluginInfo(pluginID, 19) or 0
    local localVersionStr = string.format("%1.2f", localVersion)
    local remoteVersionStr = xml:match('%s%s+version="([0-9%.]+)"')
    local remoteVersion = tonumber(remoteVersionStr or "") or 0

    if (localVersion == remoteVersion) then
        Utility.msg_prim("Version is up to date.")
        return true
    end

    Utility.msg_prim(string.format(
        "Updating from v%s to v%s...",
        localVersionStr, remoteVersionStr
    ))
    Utility.msg_sec("Please do not touch anything.")
    local fileName = GetPluginInfo(pluginID, 6)
    local file = assert(io.open(fileName, "w"))
    file:write(xml)
    file:close()
    Utility.reload_plugin()
    return true
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Utility
--------------------------------------------------

Utility = {}

function Utility.initialize()
    local modules = {
        Config,
        GMCP,
        Timer,
    }
    for _, module in ipairs(modules) do
        if (module.initialize) then
            module.initialize()
        end
    end
end

function Utility.deinitialize()
end

function Utility.print(str)
    -- Lets us use Aard color codes in our ColourNotes
    AnsiNote(stylesToANSI(ColoursToStyles(string.format("@w%s@w", str))))
end

function Utility.msg_prim(str, ...)
    Utility.print(string.format("[@YRepop Timer@w]: %s", str))
    for _, msg in ipairs{...} do
        Utility.msg_sec(msg)
    end
end

function Utility.msg_sec(str)
    Utility.print(string.format("               %s", str))
end

function Utility.pascal_case(str)
    str = str:gsub("(%a)([%w_']*)",
        function(first,remainder)
            return string.format("%s%s", first:upper(), remainder:lower())
        end
    )
    return str
end

function Utility.starts_with(s, t)
    if not (type(s) == "string" and type(t) == "string") then
        return false
    end
    return s:sub(1, #t) == t
end

function Utility.ends_with(s, t)
    return Utility.starts_with(s:reverse(), t:reverse())
end

function Utility.reload_plugin()
    if (GetAlphaOption("script_prefix") == "") then
        SetAlphaOption("script_prefix", "\\\\\\")
    end
    local scriptPrefix = GetAlphaOption("script_prefix")
    local pluginID = GetPluginID()
    local cmd = "%sDoAfterSpecial(1, \"ReloadPlugin('%s')\", sendto.script)"
    Utility.msg_prim("Reloading...")
    Execute(cmd:format(scriptPrefix, pluginID))
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Plugin Callbacks
--------------------------------------------------

function OnPluginConnect()
    Send_GMCP_Packet("request room")
end

function OnPluginInstall()
    Utility.initialize()
    if (IsConnected()) then
        OnPluginConnect()
    end
    Utility.msg_prim("Plugin installed. Submit @Yart help @wfor help.")
end

function OnPluginEnable()
    OnPluginInstall()
end

function OnPluginClose()
    Utility.deinitialize()
end

function OnPluginDisable()
    OnPluginClose()
end

function OnPluginBroadcast(msg, id, name, text)
    if (id == "3e7dedbe37e44942dd46d264" and text == "comm.repop") then
        GMCP.repop()
    end
end
]]>
</script>


</muclient>
