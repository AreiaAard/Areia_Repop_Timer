<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
    name="Areia_Repop_Timer"
    author="Areia"
    id="eb83ae87839b08cf69f80ad2"
    language="Lua"
    purpose="Track area repops"
    save_state="y"
    date_written="2021-12-30 15:00:00"
    requires="5.06"
    version="0.04"
    >
<description trim="y">
<![CDATA[
]]>
</description>

</plugin>

<include name="constants.lua"/>



<aliases>
    <alias
        match="^ *art +config +chan(?:nel)? *$"
        enabled="y"
        script="Config.channel"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +chan(?:nel)? +(?<val>\w.*\w) *$"
        enabled="y"
        script="Config.channel"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>

    <alias
        match="^ *art +config +alias(?:es)? *$"
        enabled="y"
        script="Config.zone_aliases"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +alias(?:es)? +(?<alias>\w+) *$"
        enabled="y"
        script="Config.zone_aliases"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +alias(?:es)? +(?<alias>\w+) +(?<zone>\w+) *$"
        enabled="y"
        script="Config.zone_aliases"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>

    <alias
        match="^ *art +config +notif(?:y|ications?) *$"
        enabled="y"
        script="Config.notify"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +notif(?:y|ications?) +(?<val>on|off) *$"
        enabled="y"
        script="Config.notify"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>

    <alias
        match="^ *art +config +absolute *$"
        enabled="y"
        script="Config.absolute"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +config +absolute +(?<threshold>\d+) *$"
        enabled="y"
        script="Config.absolute"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
require "commas"
require "copytable"
require "gmcphelper"
require "serialize"
require "tprint"
require "var"
require "wait"
dofile(GetInfo(60) .. "aardwolf_colors.lua")



--------------------------------------------------
-- Config
--------------------------------------------------

Config = {}

function Config.initialize()
    Config.load()
end

function Config.default()
    local data = {
        ["channel"] = "",
        ["zoneAliases"] = {},
        ["notify"] = true,
        ["absoluteThreshold"] = 3600,
    }
    return serialize.save_simple(data)
end

function Config.load()
    local strvar = var.config or Config.default()
    local data = loadstring("return " .. strvar)()
    Config.data = data
end

function Config.save()
    var.config = serialize.save_simple(Config.data)
end

function Config.get(key)
    return Config.data[key]
end

function Config.set(key, val)
    Config.data[key] = val
    Config.save()
end

function Config.channel(alias, line, wc)
    local val = wc.val and wc.val:lower() or nil
    if (val) then
        val = val == "default" and "" or val
    Config.set("channel", val)
    end

    val = Config.get("channel")
    val = val == "" and "plugin message" or val
    Utility.msg_prim(string.format("Default channel is %s.", val))
end

function Config.display_zone_aliases(alias)
    local zoneAliases = Config.get("zoneAliases")
    local display = {}

    if (alias) then
        table.insert(display, alias)
    else
        for alias, _ in pairs(zoneAliases) do
            table.insert(display, alias)
        end
    end

    if (#display == 0) then
        Utility.msg_prim("No zone aliases are defined.")
        return
    end

    table.sort(display)
    Utility.msg_prim("@YAlias    @w: @YZone:")
    Utility.msg_sec("---------:-----------")
    for _, alias in ipairs(display) do
        local zone = zoneAliases[alias]
        local line = string.format(
            "%-8.8s : %-10.10s", alias,
            zone and Utility.pascal_case(zone) or "(None)"
        )
        Utility.msg_sec(line)
    end
end

function Config.set_zone_alias(zone, alias)
    if not (zone and alias) then
        return
    end

    zone = zone:lower()
    alias = alias:lower()
    if (zone == "remove") then
        Config.get("zoneAliases")[alias] = nil
        Config.save()
        Utility.msg_prim(string.format("Removed zone alias %s.", alias))
        return
    end

    Config.get("zoneAliases")[alias] = zone
    Config.save()
    Config.display_zone_aliases(alias)
end

function Config.check_zone_alias(zone)
    zone = zone:lower()
    return Config.get("zoneAliases")[zone] or zone
end

function Config.zone_aliases(alias, line, wc)
    local zone = wc.zone
    local alias = wc.alias
    if (zone) then
        return Config.set_zone_alias(zone, alias)
    end
    Config.display_zone_aliases(alias)
end

function Config.notify(alias, line, wc)
    local val = wc.val and wc.val:lower() or nil
    if (not val) then
        -- Flip the flag if no arg was given.
        val = Config.get("notify") and "off" or "on"
    end

    if (val == "on") then
        Config.set("notify", true)
    elseif (val == "off") then
        Config.set("notify", false)
    else
        Utility.plugin_msg("Syntax: @Yart config notify [on|off]")
        return
    end

    val = Config.get("notify") and "on" or "off"
    Utility.msg_prim(string.format("Pre-repop notifications turned %s.", val))
end

function Config.absolute(alias, line, wc)
    local threshold = tonumber(wc.threshold)
    if (threshold) then
        -- Receive arg as minutes, but store it as seconds.
        Config.set("absoluteThreshold", threshold * 60)
    end

    threshold = Config.get("absoluteThreshold") / 60
    if (threshold < 1) then
        Utility.msg_prim("Absolute time formats turned off.")
        return
    end
    Utility.msg_prim(string.format(
        "Absolute time format will be used for repops over %d minute%s.",
        threshold, threshold > 1 and "s" or ""
    ))
end
]]>
</script>



<aliases>
    <alias
        match="^ *art +time *$"
        enabled="y"
        script="Tracker.track"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +time +(?<zone>\w+) *$"
        enabled="y"
        script="Tracker.track"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +time +(?<zone>\w+) +(?<channel>\w.*\w) *$"
        enabled="y"
        script="Tracker.track"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>

    <alias
        match="^ *art +reset *$"
        enabled="y"
        script="Tracker.reset"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
    <alias
        match="^ *art +reset +(?<zone>\w+) *$"
        enabled="y"
        script="Tracker.reset"
        regexp="y"
        ignore_case="y"
        sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
--------------------------------------------------
-- Tracker
--------------------------------------------------

Tracker = {}

function Tracker.refresh_data()
    local now = os.time()
    Sense.refresh_times(now)
    GMCP.refresh_repop(now)
end

function Tracker.announce_repop(zone, channel)
    if (not zone) then
        return
    end

    local msg = Time.get_repop(zone)
    channel = channel and channel:lower() or Config.get("channel")
    if (channel == "") then
        Utility.msg_prim(msg)
        return
    end
    Execute(string.format("%s %s", channel, msg))
end

function Tracker.track(alias, line, wc)
    local channel = wc.channel
    local zone = wc.zone
    Tracker.refresh_data()

    -- Default to the current area. If no sense data for that zone
    -- is stored, then sense life. If there is sense data for that
    -- zone, or if a zone arg was given, then announce the repop.
    if (not zone) then
        zone = GMCP.get_zone()
        if (not Sense.times[zone]) then
            Sense.life()
            return
        end
    end

    zone = Config.check_zone_alias(zone)
    Tracker.announce_repop(zone, channel)
end

function Tracker.reset(alias, line, wc)
    local zone = wc.zone and Config.check_zone_alias(wc.zone) or nil
    Sense.clear_times(zone)
    GMCP.clear_repop(zone)

    local msg = "Reset repop data for %s."
    msg = msg:format(zone and Utility.pascal_case(zone) or "all areas")
    Utility.msg_prim(msg)
end
]]>
</script>



<triggers>
    <trigger
        group="triggerg_sense_life"
        match="^You are in area : (?<areaName>.+)$"
        enabled="n"
        script="Sense.area"
        regexp="y"
        sequence="100"
    >
    </trigger>

    <trigger
        group="triggerg_sense_life"
        match="^You sense that life will return to this area in roughly (\d+)-(\d+) minutes\.$"
        enabled="n"
        script="Sense.minutes"
        regexp="y"
        sequence="100"
    >
    </trigger>
    <trigger
        group="triggerg_sense_life"
        match="^You sense that life will return to this area within (.+)\.$"
        enabled="n"
        script="Sense.seconds"
        regexp="y"
        sequence="100"
    >
    </trigger>
</triggers>

<script>
<![CDATA[
--------------------------------------------------
-- Sense Life
--------------------------------------------------

Sense = {}

function Sense.initialize()
    --[[ Structure of each element in Sense.times:
    zone = {
        areaName = string, -- Full area name
        nextRepop = number, -- Time of next repop
        certain = bool, -- Weather nextRepop is calculated from previous repop
    }
    ]]
    Sense.times = {}
end

function Sense.clear_times(zone)
    if (zone) then
        Sense.times[zone] = nil
        return
    end
    Sense.times = {}
end

function Sense.refresh_times(time)
    for zone, senseData in pairs(Sense.times) do
        if (time >= senseData.nextRepop) then
            Sense.clear_times(zone)
        end
    end
end

function Sense.life()
    if (not GMCP.state_active()) then
        Utility.msg_prim("You must be active to sense life.")
        return
    end
    if (not GMCP.is_ranger()) then
        Utility.msg_prim("Only rangers can sense life.")
        return
    end

    EnableTriggerGroup("triggerg_sense_life", true)
    SendNoEcho("where")
    SendNoEcho("cast 'sense life'")
end

function Sense.area(trigger, line, wc)
    Sense.currentAreaName = trim(wc.areaName)
end

function Sense.minutes(trigger, line, wc)
    local now = os.time()
    local zone = GMCP.get_zone()
    local previousRepop = GMCP.repopTimes[zone]
    local senseData = {}
    local nextRepop = 0
    local certain = false
    local timerMinutes, timerSeconds = 0, 0

    if (previousRepop) then
        certain = true
        local seconds = (previousRepop - now) % 60
        nextRepop = now + (60 * tonumber(wc[1])) + seconds
        local timerAllSeconds = nextRepop - now - 30
        timerMinutes = math.floor(timerAllSeconds / 60)
        timerSeconds = timerAllSeconds % 60
    else
        nextRepop = now + (60 * tonumber(wc[2]))
        timerMinutes = tonumber(wc[1])
    end

    Time.add_timer(
        string.format("repop_%s", zone),
        timerMinutes, timerSeconds,
        string.format("Execute('art check %s')", zone)
    )

    senseData.areaName = Sense.currentAreaName
    senseData.nextRepop = nextRepop
    senseData.certain = certain
    Sense.times[zone] = senseData

    EnableTriggerGroup("triggerg_sense_life", false)
    Tracker.announce_repop(zone)
end

function Sense.seconds(trigger, line, wc)
    local now = os.time()
    local zone = GMCP.get_zone()
    local previousRepop = GMCP.repopTimes[zone]
    local senseData = {}
    local nextRepop = now
    local certain = false
    local repopInNextSeconds = 0

    if (previousRepop) then
        certain = true
        repopInNextSeconds = (previousRepop - now) % 60
    else
        repopInNextSeconds = wc[1] == "the next 30 seconds" and 30 or 60
    end

    nextRepop = nextRepop + repopInNextSeconds
    senseData.areaName = Sense.currentAreaName
    senseData.nextRepop = nextRepop
    senseData.certain = certain
    Sense.times[zone] = senseData

    EnableTriggerGroup("triggerg_sense_life", false)
    Tracker.announce_repop(zone)
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Time
--------------------------------------------------

Time = {}

function Time.add_timer(name, minute, second, script)
    if (not Config.get("notify") or minute > 59 or second >= 60) then
        -- Invalid min/sec values, but possible to receive these for
        -- very long repop times. Probably don't want to create a
        -- timer in that case regardless.
        return
    end

    local fullName = string.format("timer_%s", name)
    local flags = timer_flag.Enabled + timer_flag.OneShot
        + timer_flag.Replace + timer_flag.Temporary
    local retVal = AddTimer(fullName, 0, minute, second, script, flags)

    if (retVal ~= eOK) then
        local errorMsg = string.format("Failed to add timer (%d):", retVal)
        Utility.msg_prim(errorMsg, error_desc[retVal])
        return
    end

    SetTimerOption(fullName, "send_to", sendto.script)
end

function Time.convert_relative_time(time)
    local day, hour, minute, second = 0, 0, 0, 0

    local dayLength = 60 * 60 * 24
    if (time >= dayLength) then
        day = math.floor(time / dayLength)
        time = time % dayLength
    end

    local hourLength = 60 * 60
    if (time >= hourLength) then
        hour = math.floor(time / hourLength)
        time = time % hourLength
    end

    local minuteLength = 60
    if (time >= minuteLength) then
        minute = math.floor(time / minuteLength)
        time = time % minuteLength
    end

    second = time
    return {day=day, hour=hour, minute=minute, second=second}
end

function Time.format_relative_repop(senseData, now)
    local conversion = Time.convert_relative_time(senseData.nextRepop - now)
    local approximate = senseData.certain and "" or "approximately "
    local timeSpans = {}

    for _, span in ipairs{"day", "hour", "minute", "second"} do
        local spanCount = conversion[span]
        if (spanCount > 0) then
            --local plural = spanCount > 1 and "s" or ""
            --local str = string.format("%d %s%s", spanCount, span, plural)
            local str = string.format("%d%s", spanCount, span:sub(1, 1))
            table.insert(timeSpans, str)
        end
    end

    timeSpans = table.concat(timeSpans, ", ")
    if (timeSpans == "") then
        return "@Yhas passed"
    end
    return string.format("in %s@Y%s", approximate, timeSpans)
end

function Time.convert_absolute_time(time)
    return os.date("*t", time)
end

function Time.format_absolute_repop(senseData)
    local months = {
        "Jan", "Feb", "Mar", "May", "Jun", "Jul",
        "Aug", "Sep", "Oct", "Nov", "Dec",
    }
    local conversion = Time.convert_absolute_time(senseData.nextRepop)
    local approximate = senseData.certain and "" or "approximately "
    local str = "at %s@Y%02d:%02d:%02d on %d %s %d"
    return str:format(
        approximate, conversion.hour, conversion.min, conversion.sec,
        conversion.day, months[conversion.month], conversion.year
    )
end

function Time.format_repop(senseData, now)
    local absoluteThreshold = Config.get("absoluteThreshold")
    if (absoluteThreshold > 0
    and senseData.nextRepop - now > absoluteThreshold) then
        return Time.format_absolute_repop(senseData, now)
    end
    return Time.format_relative_repop(senseData, now)
end

function Time.get_repop(zone)
    local now = os.time()
    local senseData = Sense.times[zone]
    zone = Utility.pascal_case(zone)
    Tracker.refresh_data()

    if (not senseData) then
        return string.format("@WNo repop data for %s.$C", zone)
    end

    local formattedRepop = Time.format_repop(senseData, now)
    return string.format(
        "@WRepop of %s %s@W.$C",
        senseData.areaName, formattedRepop
    )
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- GMCP
--------------------------------------------------

GMCP = {}

function GMCP.initialize()
    GMCP.repopTimes = {}
end

function GMCP.get_zone()
    return gmcp("room.info.zone")
end

function GMCP.is_ranger()
    local classes = gmcp("char.base.classes")
    classes = classes and classes or ""
    return classes:match("4") and true or false
end

function GMCP.state_active()
    return gmcp("char.status.state") == "3"
end

function GMCP.clear_repop(zone)
    if (zone) then
        GMCP.repopTimes[zone] = nil
        return
    end
    GMCP.repopTimes = {}
end

function GMCP.refresh_repop(time)
    for zone, repopTime in pairs(GMCP.repopTimes) do
        if (time - repopTime > 1800) then
            GMCP.clear_repop(zone)
        end
    end
end

function GMCP.event_repop()
    local now = os.time()
    local zone = GMCP.get_zone()
    GMCP.repopTimes[zone] = now
    Sense.clear_times(zone)
end
]]>
</script>



<aliases>
    <alias
     match="^ *art +update *$"
     enabled="y"
     script="Remote.update_plugin"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
--------------------------------------------------
-- Remote
--------------------------------------------------

local https = require "ssl.https"

Remote = {}

function Remote.update_plugin(alias, line, wc)
    local url = "https://raw.githubusercontent.com/AreiaAard/Areia_Repop_Timer/main/areia_repop_timer.xml"
    local xml = https.request(url)
    if (not xml) then
        Utility.msg_prim("Failed to download remote plugin file.")
        return false
    end

    local pluginID = GetPluginID()
    local localVersion = GetPluginInfo(pluginID, 19) or 0
    local localVersionStr = string.format("%1.2f", localVersion)
    local remoteVersionStr = xml:match('%s%s+version="([0-9%.]+)"')
    local remoteVersion = tonumber(remoteVersionStr or "") or 0

    if (localVersion == remoteVersion) then
        Utility.msg_prim("Version is up to date.")
        return true
    end

    Utility.msg_prim(string.format(
        "Updating from v%s to v%s...",
        localVersionStr, remoteVersionStr
    ))
    Utility.msg_sec("Please do not touch anything.")
    local fileName = GetPluginInfo(pluginID, 6)
    local file = assert(io.open(fileName, "w"))
    file:write(xml)
    file:close()
    Utility.reload_plugin()
    return true
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Utility
--------------------------------------------------

Utility = {}

function Utility.initialize()
    local modules = {
        Config,
        Sense,
        GMCP,
    }
    for _, module in ipairs(modules) do
        if (module.initialize) then
            module.initialize()
        end
    end
end

function Utility.deinitialize()
end

function Utility.print(str)
    -- Lets us use Aard color codes in our ColourNotes
    AnsiNote(stylesToANSI(ColoursToStyles(string.format("@w%s@w", str))))
end

function Utility.msg_prim(str, ...)
    Utility.print(string.format("[@YRepop Timer@w]: %s", str))
    for _, msg in ipairs{...} do
        Utility.msg_sec(msg)
    end
end

function Utility.msg_sec(str)
    Utility.print(string.format("               %s", str))
end

function Utility.pascal_case(str)
    str = str:gsub("(%a)([%w_']*)",
        function(first,remainder)
            return string.format("%s%s", first:upper(), remainder:lower())
        end
    )
    return str
end

function Utility.starts_with(s, t)
    if not (type(s) == "string" and type(t) == "string") then
        return false
    end
    return s:sub(1, #t) == t
end

function Utility.ends_with(s, t)
    return Utility.starts_with(s:reverse(), t:reverse())
end

function Utility.reload_plugin()
    if (GetAlphaOption("script_prefix") == "") then
        SetAlphaOption("script_prefix", "\\\\\\")
    end
    local scriptPrefix = GetAlphaOption("script_prefix")
    local pluginID = GetPluginID()
    local cmd = "%sDoAfterSpecial(1, \"ReloadPlugin('%s')\", sendto.script)"
    Utility.msg_prim("Reloading...")
    Execute(cmd:format(scriptPrefix, pluginID))
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Plugin Callbacks
--------------------------------------------------

function OnPluginConnect()
    Send_GMCP_Packet("request room")
end

function OnPluginInstall()
    Utility.initialize()
    if (IsConnected()) then
        OnPluginConnect()
    end
    Utility.msg_prim("Plugin installed. Submit @Yart help @wfor help.")
end

function OnPluginEnable()
    OnPluginInstall()
end

function OnPluginClose()
    Utility.deinitialize()
end

function OnPluginDisable()
    OnPluginClose()
end

function OnPluginBroadcast(msg, id, name, text)
    if (id == "3e7dedbe37e44942dd46d264" and text == "comm.repop") then
        GMCP.repop()
    end
end
]]>
</script>


</muclient>
